// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.6.0;
import '../../node_modules/@openzeppelin/contracts/access/Ownable.sol';
import '../coffeeaccesscontrol/FarmerRole.sol';
import '../coffeeaccesscontrol/DistributorRole.sol';
import '../coffeeaccesscontrol/RetailerRole.sol';
import '../coffeeaccesscontrol/ConsumerRole.sol';


contract SupplyChain is Ownable, FarmerRole, DistributorRole, RetailerRole, ConsumerRole {

    address payable owner;
    uint upc;
    uint sku;

    mapping(uint => Item) items;
    mapping(uint => string[]) itemHistory;

    enum State {
        Harvested,  // 0
        Processed,  // 1
        Packed,     // 2
        AddedToPalette,    // 3
        Sold,       // 4
        Shipped,    // 5
        Received,   // 6
        Bought   // 7
    }

    State constant defaultState = State.Harvested;

    struct Item {
        uint    sku;  // Stock Keeping Unit (SKU)
        uint    upc; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
        address payable ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        address payable originFarmerID; // Metamask-Ethereum address of the Farmer
        string  originFarmName; // Farmer Name
        string  originFarmInformation;  // Farmer Information
        string  originFarmLatitude; // Farm Latitude
        string  originFarmLongitude;  // Farm Longitude
        uint    productID;  // Product ID potentially a combination of upc + sku
        string  productNotes; // Product Notes
        uint    productPrice; // Product Price
        State   itemState;  // Product State as represented in the enum above
        address payable distributorID;  // Metamask-Ethereum address of the Distributor
        address payable retailerID; // Metamask-Ethereum address of the Retailer
        address payable consumerID; // Metamask-Ethereum address of the Consumer
    }

    event Harvested(uint upc);
    event Processed(uint upc);
    event Packed(uint upc);
    event AddedToPalette(uint upc);
    event Sold(uint upc);
    event Shipped(uint upc);
    event Received(uint upc);
    event Bought(uint upc);

    modifier verifyCaller (address _address) {
        require(msg.sender == _address, 'Error: Caller is unverified');
        _;
    }
    modifier paidEnough(uint _price) {
        require(msg.value >= _price, 'Error: Not enough paid');
        _;
    }
    modifier refundExcess(uint _upc) {
        _;
        uint _price = items[_upc].productPrice;
        uint amountToReturn = msg.value - _price;
        items[_upc].consumerID.transfer(amountToReturn);
    }
    modifier harvested(uint _upc) {
        require(items[_upc].itemState == State.Harvested, 'Error: Item not yet harvested');
        _;
    }
    modifier processed(uint _upc) {
        require(items[_upc].itemState == State.Processed, 'Error: Item not yet processed');
        _;
    }
    modifier packed(uint _upc) {
        require(items[_upc].itemState == State.Packed, 'Error: Item not yet packed');
        _;
    }
    modifier addedToPalette(uint _upc) {
        require(items[_upc].itemState == State.AddedToPalette, 'Error: Item not yet added to palette');
        _;
    }
    modifier sold(uint _upc) {
        require(items[upc].itemState == State.Sold, 'Error: Item not sold');
        _;
    }
    modifier shipped(uint _upc) {
        require(items[_upc].itemState == State.Shipped, 'Error: Item not shipped');
        _;
    }
    modifier received(uint _upc) {
        require(items[_upc].itemState == State.Received, 'Error: Item not received');
        _;
    }
    modifier bought(uint _upc) {
        require(items[_upc].itemState == State.Bought, 'Error: Item not bought');
        _;
    }

    constructor() public payable {
        owner = msg.sender;
        sku = 1;
        upc = 1;
    }

    function kill() public {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }

    function harvestCoffee(
    uint _upc,
    address payable _originFarmerId,
    string memory _originFarmName,
    string memory _originFarmInformation,
    string  memory _originFarmLatitude,
    string  memory _originFarmLongitude,
    string  memory _productNotes
    ) public onlyFarmer {
        items[_upc].sku = sku;
        items[_upc].upc = _upc;
        items[_upc].originFarmerID = _originFarmerId;
        items[_upc].originFarmName = _originFarmName;
        items[_upc].originFarmInformation = _originFarmInformation;
        items[_upc].originFarmLatitude = _originFarmLatitude;
        items[_upc].originFarmLongitude = _originFarmLongitude;
        items[_upc].productNotes = _productNotes;
        items[_upc].itemState = State.Harvested;
        emit Harvested(_upc);
        sku = sku + 1;
    }

    function processCoffee(
        uint _upc
    ) public harvested(_upc) verifyCaller(items[_upc].originFarmerID) onlyFarmer {
        items[_upc].itemState = State.Processed;
        emit Processed(_upc);
    }

    function packCoffee(
        uint _upc
    ) public processed(_upc) verifyCaller(items[_upc].originFarmerID) onlyFarmer {
        items[_upc].itemState = State.Packed;
        emit Packed(_upc);
    }

    function addCoffeeToPalette(
        uint _upc,
        uint _productPrice
    )  public packed(_upc) verifyCaller(items[_upc].originFarmerID) onlyFarmer {
        items[_upc].productPrice = _productPrice;
        items[_upc].itemState = State.AddedToPalette;
        emit AddedToPalette(_upc);
    }

    function buyCoffeePalette(
        uint _upc
    ) public addedToPalette(_upc) paidEnough(items[_upc].productPrice) refundExcess(_upc) onlyDistributor {
        items[_upc].ownerID = msg.sender;
        items[_upc].distributorID = msg.sender;
        items[_upc].itemState = State.Sold;
        items[_upc].originFarmerID.transfer(items[_upc].productPrice);
        emit Sold(_upc);
    }

    function shipCoffeePalette() {

    }

    function receiveCoffeePalette() {

    }

    function buyCoffee() {

    }

    function fetchCoffee() {

    }

    function fetchCoffeeHistory() {

    }
}