// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.6.0;
import '../../node_modules/@openzeppelin/contracts/access/Ownable.sol';
import '../coffeeaccesscontrol/FarmerRole.sol';
import '../coffeeaccesscontrol/DistributorRole.sol';
import '../coffeeaccesscontrol/RetailerRole.sol';
import '../coffeeaccesscontrol/ConsumerRole.sol';


contract SupplyChain is Ownable, FarmerRole, DistributorRole, RetailerRole, ConsumerRole {

    address owner;
    uint upc;
    uint sku;

    mapping(uint => Item) items;
    mapping(uint => string[]) itemHistory;

    enum State {
        Harvested,  // 0
        Processed,  // 1
        Packed,     // 2
        AddedToPalette,    // 3
        Sold,       // 4
        Shipped,    // 5
        Received,   // 6
        Bought   // 7
    }

    State constant defaultState = State.Harvested;

    struct Item {
        uint    sku;  // Stock Keeping Unit (SKU)
        uint    upc; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
        address ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        address originFarmerID; // Metamask-Ethereum address of the Farmer
        string  originFarmName; // Farmer Name
        string  originFarmInformation;  // Farmer Information
        string  originFarmLatitude; // Farm Latitude
        string  originFarmLongitude;  // Farm Longitude
        uint    productID;  // Product ID potentially a combination of upc + sku
        string  productNotes; // Product Notes
        uint    productPrice; // Product Price
        State   itemState;  // Product State as represented in the enum above
        address distributorID;  // Metamask-Ethereum address of the Distributor
        address retailerID; // Metamask-Ethereum address of the Retailer
        address payable consumerID; // Metamask-Ethereum address of the Consumer
    }

    event Harvested(uint upc);
    event Processed(uint upc);
    event Packed(uint upc);
    event ForSale(uint upc);
    event Sold(uint upc);
    event Shipped(uint upc);
    event Received(uint upc);
    event Purchased(uint upc);

    modifier verifyCaller (address _address) {
        require(msg.sender == _address, 'Error: Caller is unverified');
        _;
    }
    modifier paidEnough(uint _price) {
        require(msg.value >= _price, 'Error: Not enough paid');
        _;
    }
    modifier refundExcess(uint _upc) {
        _;
        uint _price = items[_upc].productPrice;
        uint amountToReturn = msg.value - _price;
        items[_upc].consumerID.transfer(amountToReturn);
    }
    modifier harvested(uint _upc) {
        require(items[_upc].itemState == State.Harvested, 'Error: Item not yet harvested');
        _;
    }
    modifier processed(uint _upc) {
        require(items[_upc].itemState == State.Processed, 'Error: Item not yet processed');
        _;
    }
    modifier packed(uint _upc) {
        require(items[_upc].itemState == State.Packed, 'Error: Item not yet packed');
        _;
    }
    modifier addedToPalette(uint _upc) {
        require(items[_upc].itemState == State.AddedToPalette, 'Error: Item not yet added to palette');
        _;
    }
    modifier sold(uint _upc) {
        require(items[upc].itemState == State.Sold, 'Error: Item not sold');
        _;
    }
    modifier shipped(uint _upc) {
        require(items[_upc].itemState == State.Shipped, 'Error: Item not shipped');
        _;
    }
    modifier received(uint _upc) {
        require(items[_upc].itemState == State.Received, 'Error: Item not received');
        _;
    }
    modifier bought(uint _upc) {
        require(items[_upc].itemState == State.Bought, 'Error: Item not bought');
        _;
    }
}