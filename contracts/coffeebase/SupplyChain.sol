// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.6.0;
import '../../node_modules/@openzeppelin/contracts/access/Ownable.sol';
import '../../node_modules/@openzeppelin/contracts/access/AccessControl.sol';


contract SupplyChain is Ownable, AccessControl {

    address payable contractOwner;

    bytes32 public constant FARMER_ROLE = keccak256('FARMER_ROLE');
    bytes32 public constant DISTRIBUTOR_ROLE = keccak256('DISTRIBUTOR_ROLE');
    bytes32 public constant RETAILER_ROLE = keccak256('RETAILER_ROLE');
    bytes32 public constant CONSUMER_ROLE = keccak256('CONSUMER_ROLE');

    uint upc;
    uint sku;

    mapping(uint => Item) items;
    mapping(uint => string[]) itemHistory;

    enum State {
        Harvested,  // 0
        Processed,  // 1
        Packed,     // 2
        AddedToPalette,    // 3
        Sold,       // 4
        Shipped,    // 5
        Received,   // 6
        SaleInitialized, // 7
        Bought   // 8
    }

    State constant defaultState = State.Harvested;

    struct Item {
        uint    sku;  // Stock Keeping Unit (SKU)
        uint    upc; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
        address payable ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        address payable originFarmerID; // Metamask-Ethereum address of the Farmer
        string  originFarmName; // Farmer Name
        string  originFarmInformation;  // Farmer Information
        string  originFarmLatitude; // Farm Latitude
        string  originFarmLongitude;  // Farm Longitude
        uint    productID;  // Product ID potentially a combination of upc + sku
        string  productNotes; // Product Notes
        uint    productPrice; // Product Price
        State   itemState;  // Product State as represented in the enum above
        address payable distributorID;  // Metamask-Ethereum address of the Distributor
        address payable retailerID; // Metamask-Ethereum address of the Retailer
        address payable consumerID; // Metamask-Ethereum address of the Consumer
    }

    event Harvested(uint upc);
    event Processed(uint upc);
    event Packed(uint upc);
    event AddedToPalette(uint upc);
    event Sold(uint upc);
    event Shipped(uint upc);
    event Received(uint upc);
    event SaleInitialized(uint upc);
    event Bought(uint upc);

    modifier verifyCaller (address _address) {
        require(msg.sender == _address, 'Error: Caller is unverified');
        _;
    }
    modifier paidEnough(uint _price) {
        require(msg.value >= _price, 'Error: Not enough paid');
        _;
    }
    modifier refundExcess(uint _upc) {
        _;
        uint _price = items[_upc].productPrice;
        uint amountToReturn = msg.value - _price;
        items[_upc].consumerID.transfer(amountToReturn);
    }
    modifier onlyFarmer(address _address) {
        require(hasRole(FARMER_ROLE, _address), 'Error: Not a farmer');
        _;
    }
    modifier onlyDistributor(address _address) {
        require(hasRole(DISTRIBUTOR_ROLE, _address), 'Error: Not a distributor');
        _;
    }
    modifier onlyRetailer(address _address) {
        require(hasRole(RETAILER_ROLE, _address), 'Error: Not a retailer');
        _;
    }
    modifier onlyConsumer(address _address) {
        require(hasRole(CONSUMER_ROLE, _address), 'Error: Not a consumer');
        _;
    }
    modifier harvested(uint _upc) {
        require(items[_upc].itemState == State.Harvested, 'Error: Item not yet harvested');
        _;
    }
    modifier processed(uint _upc) {
        require(items[_upc].itemState == State.Processed, 'Error: Item not yet processed');
        _;
    }
    modifier packed(uint _upc) {
        require(items[_upc].itemState == State.Packed, 'Error: Item not yet packed');
        _;
    }
    modifier addedToPalette(uint _upc) {
        require(items[_upc].itemState == State.AddedToPalette, 'Error: Item not yet added to palette');
        _;
    }
    modifier sold(uint _upc) {
        require(items[upc].itemState == State.Sold, 'Error: Item not sold');
        _;
    }
    modifier shipped(uint _upc) {
        require(items[_upc].itemState == State.Shipped, 'Error: Item not shipped');
        _;
    }
    modifier received(uint _upc) {
        require(items[_upc].itemState == State.Received, 'Error: Item not received');
        _;
    }
    modifier saleInitialized(uint _upc) {
        require(items[_upc].itemState == State.SaleInitialized, 'Error: Sale not initialized');
        _;
    }
    modifier bought(uint _upc) {
        require(items[_upc].itemState == State.Bought, 'Error: Item not bought');
        _;
    }

    constructor(address initialFarmer, address initialDistributor, address initialRetailer) public payable {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        grantRole(FARMER_ROLE, initialFarmer);
        grantRole(DISTRIBUTOR_ROLE, initialDistributor);
        grantRole(RETAILER_ROLE, initialRetailer);
        _setRoleAdmin(CONSUMER_ROLE, RETAILER_ROLE);
        contractOwner = msg.sender;
        sku = 1;
        upc = 1;
    }

    function kill() public {
        if (msg.sender == contractOwner) {
            selfdestruct(contractOwner);
        }
    }

    function harvestCoffee(
    uint _upc,
    address payable _originFarmerId,
    string memory _originFarmName,
    string memory _originFarmInformation,
    string  memory _originFarmLatitude,
    string  memory _originFarmLongitude,
    string  memory _productNotes
    ) public onlyFarmer(msg.sender) {
        items[_upc].sku = sku;
        items[_upc].upc = _upc;
        items[_upc].originFarmerID = _originFarmerId;
        items[_upc].originFarmName = _originFarmName;
        items[_upc].originFarmInformation = _originFarmInformation;
        items[_upc].originFarmLatitude = _originFarmLatitude;
        items[_upc].originFarmLongitude = _originFarmLongitude;
        items[_upc].productNotes = _productNotes;
        items[_upc].ownerID = _originFarmerId;
        items[_upc].itemState = State.Harvested;
        emit Harvested(_upc);
        sku = sku + 1;
    }

    function processCoffee(
    uint _upc
    ) public onlyFarmer(msg.sender) harvested(_upc) verifyCaller(items[_upc].originFarmerID) {
        items[_upc].itemState = State.Processed;
        emit Processed(_upc);
    }

    function packCoffee(
    uint _upc
    ) public onlyFarmer(msg.sender) processed(_upc) verifyCaller(items[_upc].originFarmerID) {
        items[_upc].itemState = State.Packed;
        emit Packed(_upc);
    }

    function addCoffeeToPalette(
    uint _upc,
    uint _productPrice
    )  public onlyFarmer(msg.sender) packed(_upc) verifyCaller(items[_upc].originFarmerID) {
        items[_upc].productPrice = _productPrice;
        items[_upc].itemState = State.AddedToPalette;
        emit AddedToPalette(_upc);
    }

    function buyCoffeePalette(
    uint _upc
    ) public payable onlyDistributor(msg.sender) addedToPalette(_upc) paidEnough(items[_upc].productPrice) refundExcess(_upc) {
        items[_upc].ownerID = msg.sender;
        items[_upc].distributorID = msg.sender;
        items[_upc].itemState = State.Sold;
        items[_upc].originFarmerID.transfer(items[_upc].productPrice);
        emit Sold(_upc);
    }

    function shipCoffeePalette(
    uint _upc
    ) public onlyDistributor(msg.sender)  sold(_upc) verifyCaller(items[_upc].ownerID) {
        items[_upc].itemState = State.Shipped;
        emit Shipped(_upc);
    }

    function receiveCoffeePalette(
    uint _upc
    ) public onlyRetailer(msg.sender) shipped(_upc) {
        items[_upc].ownerID = msg.sender;
        items[_upc].retailerID = msg.sender;
        items[_upc].itemState = State.Received;
        emit Received(_upc);
    }

    function initializeSale(
    uint _upc,
    address _consumerID
    ) public onlyRetailer(msg.sender) received(_upc) {
        items[_upc].itemState = State.SaleInitialized;
        grantRole(CONSUMER_ROLE, _consumerID);
        emit SaleInitialized(_upc);
    }

    function buyCoffee(
    uint _upc
    ) public onlyConsumer(msg.sender) saleInitialized(_upc) {
        items[_upc].ownerID = msg.sender;
        items[_upc].consumerID = msg.sender;
        items[_upc].itemState = State.Bought;
        emit Bought(_upc);
    }

    function fetchCoffee(
    uint _upc
    ) public view returns (
    uint itemSKU,
    uint itemUPC,
    uint itemState,
    address ownerID,
    address originFarmerID,
    string memory originFarmName,
    string memory originFarmInformation,
    string memory originFarmLatitude,
    string memory originFarmLongitude,
    string memory productNotes
    ) {
        Item memory item = items[_upc];

        itemSKU = item.sku;
        itemUPC = item.upc;
        itemState = uint(item.itemState);
        ownerID = item.ownerID;
        originFarmerID = item.originFarmerID;
        originFarmName = item.originFarmName;
        originFarmInformation = item.originFarmInformation;
        originFarmLatitude = item.originFarmLatitude;
        originFarmLongitude = item.originFarmLongitude;
        productNotes = item.productNotes;
    }

    function fetchCoffeeHistory(
    uint _upc
    ) public view returns (
    address ownerID,
    address originFarmerID,
    address distributorID,
    address retailerID,
    address consumerID,
    uint itemState
    ) {
        Item memory item = items[_upc];

        ownerID = item.ownerID;
        originFarmerID = item.originFarmerID;
        distributorID = item.distributorID;
        retailerID = item.retailerID;
        consumerID = item.consumerID;
        itemState = uint(item.itemState);
    }
}